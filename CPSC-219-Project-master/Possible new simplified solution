/**This is an attempt at simplified alternate solution for Friday. I am not sure how to use a spot on the map, so I 
am currently putting it as an ArrayList. Does anyone know how best to pass something like this in a parameter?
Pseudocode:
  copyMap from Nicki
  setStart
  setEnd
  add start to list
  make start the currentSpot
  do: loop through possible moves(neighbouring spots)
      check if valid move
      if valid,
        measure each distance to end 
        choose shortest to end
      add spot to list 
      make the spot currentSpot
    while: check currentSpot is the end
 if current is end
  print list
 else 
  say no path
  
  Typed UML 
    Class Path
    -listOfMoves:ArrayList
    -currentSpot: Array coordinate
    -columnNumber: int
    -rowNumber: int
    
    +setStart(startLocation: Array coordinate)
    +setEnd(endLocation: Array coordinate)
    +getStart(): Array coordinate
    +getEnd(): Array coordinate
    +distanceToEnd(potentialSpot: Array coordinate, end: Array coordinate):int
    +Path(gridToCopy:Array):Array
    +isValidMove(potentialSpot:Array coordinate):boolean
    +possibleNewSpots(thisCurrentSpot:Array coordinate, newPossibleSpot: Array coordinate)
    +addToPath(newSpot:Array coordinate)
    +displaySuccessfulPath(successfulPath:ArrayList)
    +findMapSize(map:Array)
    */

public class Path{
  private ArrayList<int> listOfMoves;
  private ArrayList<int> currentSpot;
  private int columnNumber;
  private int rowNumber;
  
  // Copy constructor. Copied from Nicki's Map Class code
  public Path(Map gridToCopy){
    for(row =0; row <12; row++){
      for(column =0; column <18; column++){
        grid[row][column] = gridToCopy.grid[row][column];
      }
    }
  }
  
  //set start coordinates on the map
  public void setStart(ArrayList<int> startLocation){
    ArrayList<int> start = new ArrayList<int>;
    start = startLocation;
  }
  
  //set end coordinates on the map
  public void setEnd(ArrayList<int> endLocation){
    ArrayList<int> end = new ArrayList<int>;
    end = endLocation;
  }

  //get the start location
  public ArrayList<int> getStart (){
    return start;
  }
  
  //get the end location
  public ArrayList<int> getEnd (){
    return end;
  }
  
  //find the map size in columns and rows
  public void findMapSize(Array[][] map){
    int i;
    columnNumber=map.length();
    rowNumber=map[i].length();
  }

  //any possible new spots to move from the current square can be checked to find the best one
  public void possibleNewSpots(ArrayList <int> thisCurrentSpot, ArrayList <int> newPossibleSpot){
    //check if new moves are valid
    if (thisCurrentSpot.isValidMove(newPossibleSpot[x][y])){
      //if valid, choose shortest distance to end
      if (thisCurrentSpot.distanceToEnd(thisCurrentSpot[x][y],end) > (newPossibleSpot.distanceToEnd(newPossibleSpot[x][y], end))){
        currentSpot = newPossibleSpot[x][y];
      }
    }
  }
  
  //calculating the distance from a potnetial new spot to move to and the end point.
  public int distanceToEnd (ArrayList <int> potentialSpot, ArrayList <int> end){
    int distance = (potentialSpot.x - end.x) + (potentialSpot.y - end.y);
    return distance;
  }
  
  //checks if a potential spot is a valid place to move
  public boolean isValidMove(ArrayList <int> potentialSpot){
    boolean validMove = false;
    if (potentialSpot.equals(end) || (!potentialSpot.equals(0))){
      validMove = true;
    }
    return validMove;
  }
  
  //adds the successful new spot to the list of previous spots
  public void addToPath (ArrayList <int> newSpot){
    listOfMoves.add(newSpot);
  }
  
  //if the end is found, display the successful path.
  public void displaySuccessfulPath(ArrayList <int> successfulPath){
    for (int i=0; i<successfulPath.length; i++){
      for (int j=0; j<successfulPath[i].length; j++){
        System.out.println(successfulPath[i][j]);
      }
    }
  }
  
  //the opetation of the Path Class code. Finds a possible path from a start location to end location.
  public void findAPath (){
    grid[][] map = new grid[][];
    
    //method call to get a copy of the grid map from Nicki
    map.Path(gridToCopy);
    
    //method call to find the map dimensions
    findMapSize(map);
    
    //method call to set start point on grid map
    map.setStart();
    
    //method call to set end point on grid map
    map.setEnd();
    
    //method call to add start point to solution list
    listOfMoves.addToPath(start);
    
    currentSpot = start;
    int distanceValue = currentSpot.distanceToEnd(currentSpot, end);
    //do while loop to find new spot to move on way to end point. Logic will be off because it will go with first available better space, as opposed to optimal move.
    do{//loop through possible moves.
      if (x<columnNumber-1){
        //call method to see if this move is an improvement
        possibleNewSpot(currentSpot[x][y], currentSpot[x+1][y]);
      }
      if (x>0){
      //call method to see if this move is an improvement
        possibleNewSpot(currentSpot[x][y], currentSpot[x-1][y]);
      }
      if (y<rowNumber-1){
      //call method to see if this move is an improvement
        possibleNewSpot(currentSpot[x][y], currentSpot[x][y+1]);
      }
      if (y>0){
      //call method to see if this move is an improvement
        possibleNewSpot(currentSpot[x][y], currentSpot[x][y-1]);
      }
      if (x<columnNumber-1 && y>0){
      //call method to see if this move is an improvement
        possibleNewSpot(currentSpot[x][y], currentSpot[x+1][y-1]);
      }
      if (x> 0 && y>0){
      //call method to see if this move is an improvement
        possibleNewSpot(currentSpot[x][y], currentSpot[x-1][y-1]);
      }
      if (x >0  && y< rowNumber-1){
      //call method to see if this move is an improvement
        possibleNewSpot(currentSpot[x][y], currentSpot[x-1][y+1]);
      }
      if (x< columnNumber-1 && y<rowNumber-1){
      //call method to see if this move is an improvement
        possibleNewSpot(currentSpot[x][y], currentSpot[x+1][y+1]);
      }
      
      //add it to list
      listOfMoves.addToPath(currentSpot);
    }while (!currentSpot.equals(end));
    
    //if current location is the end, print the list of successful moves
    if (currentSpot.equals(end)){
      listOfMoves.displaySuccessfulPath(listOfMoves);
    }//if cannot find a successful path, print a message saying so. Currently no way to decide when no path can be found
    else{
      System.out.println("No successful path was found.");
    }
   }
  }

      
    
    
    
    
