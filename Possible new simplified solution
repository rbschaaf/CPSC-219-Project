/**This is an attempt at simplified alternate solution for Friday. I am not sure how to use a spot on the map, so I 
am currently putting it as an ArrayList.
Pseudocode:
  copyMap from Nicki
  setStart
  setEnd
  add start to list
  make start the currentSpot
  do: loop through possible moves(neighbouring spots)
      check if valid move
      if valid,
        measure each distance to end 
        choose shortest to end
      add spot to list 
      make the spot currentSpot
    while: check currentSpot is the end
 if current is end
  print list
 else 
  say no path
  
  Typed UML 
    Class Path
    -listOfMoves:ArrayList
    -currentSpot: Array coordinate
    
    +setStart(startLocation: Array coordinate)
    +setEnd(endLocation: Array coordinate)
    +getStart(): Array coordinate
    +getEnd(): Array coordinate
    +distanceToEnd(potentialSpot: Array coordinate):int
    +copyMap(mapToCopy:Array):Array
    +isValidMove(newSpot:Array coordinate):boolean
    +possibleNewSpots(currentSpot:Array coordinate)
    +addToPath(newSpot:Array coordinate)
    +displaySuccessfulPath(successfulPath:ArrayList)
    */

public class Path{
  private ArrayList<int> listOfMoves;
  private ArrayList<int> currentSpot;
  
  // Copy constructor. Copied from Nicki's Map Class code
  public Path(Map gridToCopy){
    for(row =0; row <12; row++){
      for(column =0; column <18; column++){
        grid[row][column] = gridToCopy.grid[row][column];
      }
    }
  }
  
  //set start coordinates on the map
  public void setStart(ArrayList<int> startLocation){
    ArrayList<int> start = new ArrayList<int>;
    start = startLocation;
  }
  
  //set end coordinates on the map
  public void setEnd(ArrayList<int> endLocation){
    ArrayList<int> end = new ArrayList<int>;
    end = endLocation;
  }

  //get the start location
  public ArrayList<int> getStart (){
    return start;
  }
  
  //get the end location
  public ArrayList<int> getEnd (){
    return end;
  }

  //calculating the distance from a potnetial new spot to move to and the end point.
  public int distanceToEnd (ArrayList <int> potentialSpot, ArrayList <int> end){
    int distance = (potentialSpot.x - end.x) + (potentialSpot.y - end.y);
    return distance;
  }
  
  //checks if a potential spot is a valid place to move
  public boolean isValidMove(ArrayList <int> potentialSpot){
    boolean validMove = false;
    if (potentialSpot.equals(end) || (!potentialSpot.equals(0))){
      validMove = true;
    }
    return validMove;
  }
  
  //adds the successful new spot to the list of previous spots
  public void addToPath (ArrayList <int> newSpot){
    listOfMoves.add(newSpot);
  }
  
  //if the end is found, display the successful path.
  public void displaySuccessfulPath(ArrayList <int> successfulPath){
    for (int i=0; i<successfulPath.length; i++){
      for (int j=0; j<successfulPath[i].length; j++){
        System.out.println(successfulPath[i][j]);
      }
    }
  }
  
  //the bulk of the Path Class code. Finds a possible path from a start location to end location.
  public void findAPath (){
    grid[][] map = new grid[][];
    
    //method call to get a copy of the grid map from Nicki
    map.Path(gridToCopy);
    
    //method call to set start point on grid map
    map.setStart();
    
    //method call to set end point on grid map
    map.setEnd();
    
    //method call to add start point to solution list
    listOfMoves.addToPath(start);
    
    currentSpot = start;
    int distanceValue = currentSpot.distanceToEnd(currentSpot, end);
    //do while loop to find new spot to move on way to end point
    do{//loop through possible moves.
      if (x<COLS-1)
        if (currentSpot.isValidMove(currentSpot[x+1][y])){
          if (currentSpot.distanceToEnd(currentSpot,end) > (currentSpot.distanceToEnd(currentSpot[x+1][y], end)){
            currentSpot = [x+1][y];
      if (x>0)
        if (currentSpot.isValidMove(currentSpot[x-1][y])){
          if (currentSpot.distanceToEnd(currentSpot,end) > (currentSpot.distanceToEnd(currentSpot[x-1][y], end)){
            currentSpot = [x-1][y];
      if (y<ROWS-1)
        if (currentSpot.isValidMove(currentSpot[x][y+1])){
          if (currentSpot.distanceToEnd(currentSpot,end) > (currentSpot.distanceToEnd(currentSpot[x][y+1], end)){
            currentSpot = [x][y+1];
      if (y>0)
        if (currentSpot.isValidMove(currentSpot[x][y-1])){
          if (currentSpot.distanceToEnd(currentSpot,end) > (currentSpot.distanceToEnd(currentSpot[x][y-1], end)){
            currentSpot = [x][y-1];
      if (x<COLS-1 && y>0)
        if (currentSpot.isValidMove(currentSpot[x+1][y-1])){
          if (currentSpot.distanceToEnd(currentSpot,end) > (currentSpot.distanceToEnd(currentSpot[x+1][y-1], end)){
            currentSpot = [x+1][y-1];
      if (x> 0 && y>0)
         if (currentSpot.isValidMove(currentSpot[x-1][y-1])){
          if (currentSpot.distanceToEnd(currentSpot,end) > (currentSpot.distanceToEnd(currentSpot[x-1][y-1], end)){
            currentSpot = [x-1][y-1];
      if (x >0  && y< ROWS-1)
        if (currentSpot.isValidMove(currentSpot[x-1][y+1])){
          if (currentSpot.distanceToEnd(currentSpot,end) > (currentSpot.distanceToEnd(currentSpot[x-1][y+1], end)){
            currentSpot = [x-1][y+1];
      if (x< COLS-1 && y<ROWS-1)
        if (currentSpot.isValidMove(currentSpot[x+1][y+1])){
          if (currentSpot.distanceToEnd(currentSpot,end) > (currentSpot.distanceToEnd(currentSpot[x+1][y+1], end)){
            currentSpot = [x+1][y+1];
      //check if new moves are valid
      //if valid, choose shortest distance to end
      //add it to list
    }while (!currentSpot.equals(end));
    
    //if current location is the end, print the list of successful moves
    if (currentSpot.equals(end)){
      listOfMoves.displaySuccessfulPath(listOfMoves);
    }//if cannot find a successful path, print a message saying so. Currently no way to decide when no path can be found
    else{
      System.out.println("No successful path was found.");
    }
   }
  }

      
    
    
    
    
